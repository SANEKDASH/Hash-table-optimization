# Hash-table-optimization
Эта __научно-популярная__ статья расскажет вам о том, как работает хеш-таблица и
как можно оптимизировать различные алгоритмы, используемые в ней, с  помощью Ассемблера.

## Что такое хеш-таблица?
<img src="./readme_src/hash_table.png" alt="hash_table.png" width="800"/>

Хеш-таблица - структура данных, которая базируется на соответствии ключа (какие-то данные) и его хеш-значения (какое-то число, зависящее от ключа).
Ключ с его хеш-значением обычно называют парой.

Хеш-таблица позволяет выполнять над собой три операции:
1) Поиск пары по ключу.
2) Добавление пары.
3) Удаление пары.


Большой __плюс__ хеш-таблицы - скорость по сравнению с другими.

>В лучшем случае, доступ к данным можно совершить за $O(1)$.
>В худшем (при возникновении коллизий) - за $O(n)$.

Большой __минус__ хеш-таблицы - использование большого кол-ва памяти по сравнению с другими структурами данных.
Но в наше время __дешевле__ повысить __объем__ оперативной памяти, чем повысить __производительность__ процессора.
Поэтому хеш-таблицы пользуются популярностью в определенных задачах.

### Коллизии
Ситуацию, при которой разным ключам соответствует одно и то же хеш-значение называется __коллизией__.

Существует несколько методов разрешения проблемы коллизий:
1) __Открытая адресация__:
        В массиве хранятся пары. А поиск идет
        в определенном порядке (обычно - в линейном или квадратичном).

2) __Списки__:
    Массив состоит из списков, содержащих пары с одинаковыми хеш-значениями.

3) __Двойное хеширование__:
    Грамотно подбираются две независимые хеш-функции: $h_1(x)$ и $h_2(x)$.
    Пусть $j$ - номер проверяемой ячейки, а $n$ - размер хеш-таблицы. Тогда поиск происходит следующим образом:

    $j_1 = (h_1(x))\ mod\ n$

    $j_2 = (h_1(x) + h_2(x))\ mod\ n$

    ...

    $j_i = (h_1(x) + (i - 1) * h_2(x))\ mod\ n$

4) __Переход к сбалансированному дереву__:
    Когда кол-во элементов в списке превышает определенное количество, можно заменить __односвязный список__ на __бинарное дерево поиска__. Этот метод может ускорить поиск от __$O(n)$__.

В своей реализации я использовал метод списков.

### Load Factor

$Load\ factor$ - характеристика хеш-таблицы, описывающая среднее кол-во элементов в одном подмножестве.

Идеальным этот показатель считается когда $load\ factor \in (0;1 ]$.

В динамических хеш-таблицах (те, которые могут расширять кол-во списков) $load\ factor$ поддерживается около 1 с помощью добавления списков. Такие действия облегчают поиск и делают его алгоритмическую сложность __$O(1)$__.

В этой работе мы пользуемся статической хеш-таблицей (т.е. без возможности добавлять списки),
т.к в этой работе я хочу __ускорить__ алгоритмы хеш-таблицы, а при увеличении количества списков нужно проводить __рехеширование__ и __реаллокацию__, что замедляет их работу.

Для тестирования в хеш-таблицу загружался текст произведения Шекспира "Гамлет" поделенный на слова.

Размер хеш-таблицы подобрали так, чтобы получить $load\ factor$ равным примерно 7. Это позволит лучше увидеть узкие места в различных алгоритмах данной структуры данных.

Но мы заранее не знаем, сколько уникальных слов в тексте.

Поэтому алгоритм действий был следующим:
1)  Загрузить текст в хеш-таблицу.

>Функция добавления проверяет,
>существует ли добавляемый элемент таблице, если есть - не добавляет

2) Узнаем, сколько уникальных слов в тексте.

>Это число можно узнать по кол-ву элементов в хеш-таблице после загрузки
>Запоминаем это число.

3) Создаем новую хеш-таблицу, базируясь на известном кол-ве уникальных
элементов и load factor'е.

## Анализ хеш-функций
Для тестирования хеш-функций сначала в хеш-таблицу загружался текст произведения Шекспира "Гамлет" поделенный на слова.

__Количество списков__, полученное из алгоритма, указанного в предыдущем пункте, равно __797__


Идеальной хеш-функцией считается та, которая может обеспечить равномерное распределение элементов
хеш-таблицы по ее подмножествам/спискам при минимальном кол-ве __коллизий__.

Соответственно, мы можем определить насколько хорош алгоритм хеширования используя
такую вещь, как __дисперсия__.

__Дисперсия__ характеризует, насколько количество элементов в подможествах отличается от среднего количества элементов в подмножестве.

Считается дисперсия по следующей формуле:
$\sigma^{2} = \frac{\sum_{i = 1}^{n}(x_i - \overline{x})^2}{n}$

Соответственно, __меньше__ дисперсия --> __равномернее__ распределение --> __лучше__ хеш-алгоритм.

Так же для наглядности удобно строить __гистограммы заселенности__ хеш-таблицы.
С помощью них можно видеть само распределение элементов по подмножествам.

Далее будут приведены дисперсии и гистограммы заселенности для нескольких
реализованных мной хеш-алгоритмов.

1) хеш-функция, возвращающая ноль (далее ZeroHash):
```cpp
static uint64_t ZeroHash(char *data)
{
    return 0;
}

```

Гистограмма заселенности:
![alt text](./readme_src/zero_hash_diag.png)

Дисперсия: 40152.63

2) хеш-функция, возвращающая ASCII код первого символа в слове (далее StupidHash):
```cpp
static uint64_t StupidHash(char *data)
{
    return *data;
}

```


Гистограмма заселенности:
![alt text](./readme_src/stupid_hash_diag.png)

Дисперсия: 1741.259

3) хеш-функция, возвращающая длину слова (далее StrlenHash):
```cpp
static uint64_t StrlenHash(char *data)
{
    return strlen(data);
}

```


Гистограмма заселенности:
![alt text](./readme_src/strlen_hash_diag.png)

Дисперсия: 5558.15

4) хеш-функция, возвращающая сумму ASCII кодов всех символов в слове (далее SumHash):
```cpp
static uint64_t SumHash(char *data)
{
    uint64_t sum = 0;

    for (size_t i = 0; data[i] != '\0'; i++)
    {
        sum += data[i];
    }

    return sum;
}
```


Гистограмма заселенности:
![alt text](./readme_src/sum_hash_diag.png)

Дисперсия: 42.29

Может показаться, что эта хеш-функция весьма неплоха, но в действительности все иначе.
Давайте посмотрим на гистограмму заселенности хеш-таблицы, использующей эту функцию, с 4 тысячами списков:

![alt text](./readme_src/sum_hash_4k_diag.png)

Видим, что распределение элементов здесь отнюдь не равномерное, и большая часть списков не задействуется.
Отсюда делаем вывод, что эту хеш-функцию лучше не использовать.

5) хеш-функция, возвращающая частное от суммы ASCII кодов всех символов в слове и его длинны (далее SumStrlenHash):
```cpp
static uint64_t SumStrlenHash(char *data)
{
    uint64_t sum = SumHash(data);

    uint64_t word_len = strlen(data);

    if (word_len == 0)
    {
        return 0;
    }

    return (uint64_t) (sum / word_len);
}
```


Гистограмма заселенности:
![alt text](./readme_src/sum_strlen_hash_diag.png)


Дисперсия: 2925.81

6) хеш-функция, использующая циклический сдвиг вправо (далее RorHash):
```cpp
static uint64_t RorHash(char *data)
{
    uint64_t hash_val = 0;

    for (size_t i = 0; data[i] != '\0'; i++)
    {
        hash_val = ((hash_val >> 1) | (hash_val << 63)) ^ data[i];
    }

    return hash_val;
}
```

Гистограмма заселенности:
![alt text](./readme_src/ror_hash_diag.png)


Дисперсия: 27.98

7) Хещ-функция использующая циклический сдвиг влево (Далле RolHash):
```cpp
static uint64_t RolHash(char *data)
{
    uint64_t hash_val = 0;

    for (size_t i = 0; data[i] != '\0'; i++)
    {

        hash_val = ((hash_val << 1) | (hash_val >> 63)) ^ data[i];

    }

    return hash_val;
}
```

Гистограмма заселенности:
![alt text](./readme_src/rol_hash_diag.png)
Дисперсия: 13.27

8) CRC32Hash:
```cpp
uint64_t CRC32Hash(char *data)
{
    uint32_t mask = 0;

    uint32_t hash_val = 0xFFFFFFFF;

    for (size_t i = 0; data[i] != 0; i++)
    {
        hash_val = hash_val ^ ((uint32_t) data[i]);

        for (size_t j = 0; j < 8; j++)
        {
            mask = -(hash_val & 1);

            hash_val = (hash_val >> 1) ^ (0xEDB88320 & mask);
        }
    }

    return (uint64_t) ~hash_val;
}
```

Гистограмма заселенности:
![alt text](./readme_src/crc32_hash_diag.png)

Дисперсия: 9.58

### Странные дела с RorHash() и RolHash()
Хочется сделать замечание по поводу этих двух хеш-функций.

Почему-то случилось так, что в ассемблере существуют инструкции
ror и rol (циклический сдвиг вправо и влево соответственно), но в языках C/C++ они не реализованы.

Используя сайт [godbolt.org](https://godbolt.org/) я посмотрел, во что компилятор преобразует
код этих двух интересных функций.

Моему удивлению не было предела, когда я увидел заветные инструкции ror и rol:

<img src="./readme_src/ror_rol.png" alt="hash_table.png" width="800"/>

Видимо компилятор g++ достаточно умен, чтобы найти в коде ror и rol.


После всех замечаний и анализа хеш-функций
можем видеть, что наиболее равномерное распределение элементов по спискам предоставляет хеш-функция CRC32Hash().

Поэтому далее будем использовать ее.

Теперь давайте перейдём к оптимизации.

## Поиск узких мест
Чтобы что-то оптимизировать, сначала нужно узнать, что в программе требует оптимизации. То есть нужно найти так называемые __узкие места__.

Для поиска узких мест в алгоритмах хеш-таблицы я использовал утилиту __perf__.

Для тестов был взят текст произведения Шекспира "Король Лир", поделенный на слова.

Тест представляет из себя поиск всех слов из "Короля Лир" среди ранее загруженных слов из "Гамлета" 2560 раз.

Для начала проведем __профилирование для базовой версии (без оптимизации)__.
Вот его результаты:

```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# ........  .........  ....................  ................................................................
#
    74.57%  HashTable  HashTable             [.] CRC32Hash(char*)
    10.93%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
     7.16%  HashTable  libc.so.6             [.] __strcmp_evex
     5.85%  HashTable  HashTable             [.] HashTableFindElem(HashTable*, char*, HashTablePos*)
     0.83%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          8 151,97 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,14% )
                31      context-switches                 #    3,803 /sec                        ( +- 12,12% )
                 1      cpu-migrations                   #    0,123 /sec                        ( +- 27,60% )
             3 569      page-faults                      #  437,808 /sec                        ( +-  0,00% )
    36 386 485 830      cycles                           #    4,464 GHz                         ( +-  0,07% )
    52 384 152 116      instructions                     #    1,44  insn per cycle              ( +-  0,00% )
     5 146 179 595      branches                         #  631,281 M/sec                       ( +-  0,00% )
           391 943      branch-misses                    #    0,01% of all branches             ( +- 24,15% )
                        TopdownL1                 #     65,6 %  tma_backend_bound
                                                  #      5,1 %  tma_bad_speculation
                                                  #      0,4 %  tma_frontend_bound
                                                  #     28,9 %  tma_retiring             ( +-  0,07% )

            8,1528 +- 0,0114 seconds time elapsed  ( +-  0,14% )

------------------------------------------------------------------------------------------------------------+
```

__Результаты профилирования для базовой версии + O3__:

```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    51.85%  HashTable  HashTable         [.] CRC32Hash(char*)
    18.45%  HashTable  libc.so.6         [.] __strcmp_evex
    16.21%  HashTable  HashTable         [.] ListFind(List*, char*, unsigned long*)
    10.97%  HashTable  HashTable         [.] TestHashTable(HashTable*, WordSet*)
     1.96%  HashTable  HashTable         [.] strcmp@plt

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          2 253,32 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,08% )
                 8      context-switches                 #    3,550 /sec                        ( +- 14,95% )
                 0      cpu-migrations                   #    0,000 /sec
             3 569      page-faults                      #    1,584 K/sec                       ( +-  0,01% )
    10 062 631 047      cycles                           #    4,466 GHz                         ( +-  0,05% )
    22 938 934 302      instructions                     #    2,28  insn per cycle              ( +-  0,00% )
     1 594 637 228      branches                         #  707,685 M/sec                       ( +-  0,00% )
           117 260      branch-misses                    #    0,01% of all branches             ( +- 14,22% )
                        TopdownL1                 #     51,8 %  tma_backend_bound
                                                  #      2,1 %  tma_bad_speculation
                                                  #      1,2 %  tma_frontend_bound
                                                  #     44,9 %  tma_retiring             ( +-  0,08% )

           2,25392 +- 0,00170 seconds time elapsed  ( +-  0,08% )

------------------------------------------------------------------------------------------------------------+
```


Как можем заметить, __узкими местами__ в алгоритмах хеш-таблицы __являются__ следующие __функции__:
1) __CRC32Hash()__
2) __ListFind()__ (вызывается следующей функцией)
3) __HashTableFindElem()__

>__strcmp_evex() я здесь не учел, так как эту функцию писали мужики, знающие свое дело.
>Вряд ли я смогу его ускорить, но есть одна хитрость, которая мне в этом поможет.
>Позже я вам о ней поведаю.

__Что ж, давайте оптимизировать!__

## Оптимизация

Перед тем, как приступить к оптимизации хотелось бы подчеркнуть тот факт, что __ускорение__, полученное мной, __может розниться__
от системы к системе. Ускорение зависит от различного множества всяческих факторов: от версии компилятора до
комплектующих вашего ПК.
Ниже приведены параметры моей системы:

|                               |                        |
|:-----------------------------:|:----------------------:|
|Процессор                      | Intel core i5 11400H.  |
|Кол-во оперативной памяти      | 16гб.                  |
|ОС                             | Ubuntu Linux 22.04.4.  |
|Версия ядра Ubuntu             | 6.5.0-26-generic.      |
|Используемый компилятор        | g++                    |
|Версия компилятора             | 11.4.0                 |

Так же стоит отметить такое явление как __троттлинг__.

__Троттлингом__ называют занижение тактовой частоты процессора, чтобы не допустить термических повреждений при перегреве.

Особенно это можно наблюдать на ноутбуках, когда система охлаждения не справляется со своей задачей при
высокой нагрузке на процессор.

Собственно, давайте посмотрим, как ведет себя в тестах мой Intel core i5 11400h.

Для этого я использовал утилиту __psensor__.

Получил следующий график температур от времени:
<img src="./readme_src/cpu_temp.png" alt="hash_table.png" width="800"/>

Видно, что в целом температура во время теста не превышает __77 градусов Цельсия__.
Для ноутбука это __хороший показатель__.

Но интерес вызывают кратковременные скачки температуры с 70 градусов до примерно 65.
Если сосчитать их количество, то получится число 20.

Это число не взялось с потолка, так как 20 - количество итераций тестов, проводимых утилитой perf.
Так мы описали, на первый взгляд кажущееся случайным, закономерное явление.

Ну а теперь после всех описания всевозможных подводных камней
попытаемся оптимизировать самую тяжелую функцию - __функцию хеширования__.

### Оптимизация №1: хеш-функция

Так совпало (зуб даю, реально совпало), что существует:
1) инструкция процессора __crc32__
2) intrinsic функция ___mm_crc32_u8()__

 А методов реализовывать оптимизацию существует аж целых 3:
1) функция языка Си под названием asm()
2) функция написанная на языке Ассемблер, вызываемая в Си
3) intrinsic функции

Для примера я написал функцию на Ассемблере, которая считает хеш CRC32:
```nasm
asm_CRC32Hash:
; Entering function
    push rbp
    mov rbp, rsp

    xor rax, rax
; Hash start value
    mov eax, 0xffffffff

    jmp .HashTest
.HashCycle:
    crc32 eax, byte [rdi]

    inc rdi
.HashTest:
    cmp byte [rdi], 0
    ja .HashCycle

; Leaving function
    mov rsp, rbp
    pop rbp

    ret
```

__Результаты профилирования для версии с asm_CRC32Hash()__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object         Symbol
# ........  .........  ....................  ................................................................
#
    43.91%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    25.63%  HashTable  libc.so.6             [.] __strcmp_evex
    13.99%  HashTable  HashTable             [.] HashTableFindElem(HashTable*, char*, HashTablePos*)
     5.87%  HashTable  HashTable             [.] asm_CRC32Hash.HashTest
     4.67%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
     3.35%  HashTable  HashTable             [.] strcmp@plt
     1.86%  HashTable  HashTable             [.] asm_CRC32Hash

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          1 090,99 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,83% )
                 4      context-switches                 #    3,666 /sec                        ( +- 15,31% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    3,270 K/sec                       ( +-  0,01% )
     4 726 720 243      cycles                           #    4,332 GHz                         ( +-  0,21% )
    13 781 524 236      instructions                     #    2,92  insn per cycle              ( +-  0,00% )
     2 115 240 637      branches                         #    1,939 G/sec                       ( +-  0,00% )
           313 011      branch-misses                    #    0,01% of all branches             ( +- 71,07% )
                        TopdownL1                 #     31,0 %  tma_backend_bound
                                                  #      2,5 %  tma_bad_speculation
                                                  #      6,5 %  tma_frontend_bound
                                                  #     60,0 %  tma_retiring             ( +-  0,18% )

           1,09149 +- 0,00901 seconds time elapsed  ( +-  0,83% )

------------------------------------------------------------------------------------------------------------+
```

Как можем видеть, функция хеширования сдвинулась с первого на последнее место в чарте вызовов.
Это не может не радовать.
Но у нас все еще осталась работа в виде оптимизации функции поиска.

### Оптимизация №2: поиск

Как можем видеть из чарта вызовов, в функции HashTableFindElem() расходуется на ListFInd() и __strcmp_evex(), который вызывается с-под ListFind().

Оптимизация __strcmp_evex() является довольно сложной ~~быть может невозможной~~ задачей, так как он уже оптимизирован.
Хитрость в этом случае заключается в том, что в данной задаче (поиск заранее известных слов) мы можем переити от общего к частному.

> Длины слов в обоих текстах не превышают 37 --> не превышают 64 символов.

С помощью технологии AVX-512, поддерживаемой на моем процессоре, я попытался ускорить алгоритм поиска, используя intrinsic функции.

Список используемых intrinsic функций:
1) _mm512_load_epi64() - загружает в регистр 64 байт памяти, расположенной по адресу, выравненному по 64.

2) _mm512_cmp_epi16_mask() - сравнивает две пачки памяти по 64 байт каждая.

__Результаты профилирования для версии asm_CRC32Hash() + O3 (до оптимизации поиска)__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object         Symbol
# ........  .........  ....................  ................................................................
#
    33.79%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    31.93%  HashTable  libc.so.6             [.] __strcmp_evex
    13.90%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
    10.18%  HashTable  HashTable             [.] asm_CRC32Hash.HashTest
     5.76%  HashTable  HashTable             [.] strcmp@plt
     3.26%  HashTable  HashTable             [.] asm_CRC32Hash
------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            544,64 msec task-clock                       #    0,999 CPUs utilized               ( +-  1,13% )
                 2      context-switches                 #    3,672 /sec                        ( +- 22,15% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    6,551 K/sec                       ( +-  0,01% )
     2 314 039 065      cycles                           #    4,249 GHz                         ( +-  0,19% )
     8 149 612 314      instructions                     #    3,52  insn per cycle              ( +-  0,00% )
     1 680 214 206      branches                         #    3,085 G/sec                       ( +-  0,00% )
            93 117      branch-misses                    #    0,01% of all branches             ( +-  4,70% )
                        TopdownL1                 #      8,1 %  tma_backend_bound
                                                  #      1,4 %  tma_bad_speculation
                                                  #     17,1 %  tma_frontend_bound
                                                  #     73,4 %  tma_retiring             ( +-  0,08% )

           0,54514 +- 0,00615 seconds time elapsed  ( +-  1,13% )

------------------------------------------------------------------------------------------------------------+
```

__Результаты профилирования для версии asm_CRC32Hash() + SIMD + O3 (после оптимизации поиска)__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object         Symbol
# ........  .........  ....................  ................................................................
#
    53.48%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    23.14%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
    16.76%  HashTable  HashTable             [.] asm_CRC32Hash.HashTest
     4.66%  HashTable  HashTable             [.] asm_CRC32Hash
------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            402,40 msec task-clock                       #    0,999 CPUs utilized               ( +-  1,07% )
                 2      context-switches                 #    4,970 /sec                        ( +- 28,54% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    8,867 K/sec                       ( +-  0,00% )
     1 696 988 095      cycles                           #    4,217 GHz                         ( +-  0,32% )
     5 295 247 151      instructions                     #    3,12  insn per cycle              ( +-  0,00% )
     1 239 582 166      branches                         #    3,081 G/sec                       ( +-  0,00% )
            79 113      branch-misses                    #    0,01% of all branches             ( +-  0,35% )
                        TopdownL1                 #      6,2 %  tma_backend_bound
                                                  #      1,3 %  tma_bad_speculation
                                                  #     23,5 %  tma_frontend_bound
                                                  #     69,1 %  tma_retiring             ( +-  0,28% )

           0,40287 +- 0,00428 seconds time elapsed  ( +-  1,06% )

------------------------------------------------------------------------------------------------------------+
```
Как видим, с помощью intrinsic функций получилось еще больше ускорить программу.

А strcmp() и вовсе пропал из чарта вызовов (неудивительно, т.к. он перестал использоваться).

Так же стоит отметить, что флаг __-O3__ (или -O1, -O2) здесь __существенен__, т.к. без этого флага эффективность intrinsic ф-ций заметно падает.

### Оптимизация №3: вернемся к хешу

Давайте посмотрим на еще один вариант оптимизации хеш-алгоритма - inline Ассемблер.

Язык C/C++ позволяет делать ассемблерные вставки прямо посреди основного кода программы.

Как мне кажется, к этому методу стоит только при каком-то определенном требовании свыше,
или настоять на другом методе, т.к. он достаточно сильно ухудшает читаемость кода,
особенно если используется больше одного раза.

Новая функция хеширования выглядит так:
```cpp

static inline uint64_t asm_inline_CRC32Hash(char *data)
{
    uint64_t hash_val = 0;

        asm(
            "    xor rax, rax                       \n"
            "    mov eax, 0xffffffff                \n"
            "    jmp HashTest                       \n"
            "HashCycle:                             \n"
            "    crc32 eax, byte ptr [%[str]]       \n"
            "    inc %[str]                         \n"
            "HashTest:                              \n"
            "    cmp byte ptr [%[str]], 0           \n"
            "    ja HashCycle                       \n"
            "    mov %[hash], rax                   \n"
                : [hash] "=m" (hash_val)
                : [str]   "d" (data)
           :);

    return hash_val;
}

```

__Результаты профилирования для версии asm_inline_CRC32Hash + SIMD ListFind + O3__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    49.18%  HashTable  HashTable         [.] ListFind(List*, char*, unsigned long*)
    21.11%  HashTable  HashTable         [.] TestHashTable(HashTable*, WordSet*)
    19.77%  HashTable  HashTable         [.] HashTest
     8.04%  HashTable  HashTable         [.] asm_inline_CRC32Hash(char*)
     0.38%  HashTable  libc.so.6         [.] _int_malloc

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            392,14 msec task-clock                       #    0,999 CPUs utilized               ( +-  0,97% )
                 2      context-switches                 #    5,100 /sec                        ( +- 39,32% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    9,099 K/sec                       ( +-  0,00% )
     1 682 623 969      cycles                           #    4,291 GHz                         ( +-  0,65% )
     5 874 968 451      instructions                     #    3,49  insn per cycle              ( +-  0,00% )
     1 312 043 248      branches                         #    3,346 G/sec                       ( +-  0,00% )
            78 707      branch-misses                    #    0,01% of all branches             ( +-  0,42% )
                        TopdownL1                 #     12,5 %  tma_backend_bound
                                                  #      1,6 %  tma_bad_speculation
                                                  #     10,1 %  tma_frontend_bound
                                                  #     75,8 %  tma_retiring             ( +-  0,31% )

           0,39257 +- 0,00380 seconds time elapsed  ( +-  0,97% )

------------------------------------------------------------------------------------------------------------+
```

__Результаты для версии asm_inline_CRC32Hash + O3__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    32.02%  HashTable  HashTable         [.] ListFind(List*, char*, unsigned long*)
    31.55%  HashTable  libc.so.6         [.] __strcmp_evex
    12.99%  HashTable  HashTable         [.] TestHashTable(HashTable*, WordSet*)
    12.11%  HashTable  HashTable         [.] HashTest
     5.24%  HashTable  HashTable         [.] strcmp@plt
     4.81%  HashTable  HashTable         [.] asm_inline_CRC32Hash(char*)
     0.27%  HashTable  libc.so.6         [.] _int_malloc

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            572,70 msec task-clock                       #    0,999 CPUs utilized               ( +-  0,78% )
                 2      context-switches                 #    3,492 /sec                        ( +- 19,83% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    6,230 K/sec                       ( +-  0,01% )
     2 513 501 962      cycles                           #    4,389 GHz                         ( +-  0,22% )
     8 729 463 053      instructions                     #    3,47  insn per cycle              ( +-  0,00% )
     1 752 697 415      branches                         #    3,060 G/sec                       ( +-  0,00% )
           115 376      branch-misses                    #    0,01% of all branches             ( +-  7,66% )
                        TopdownL1                 #      4,6 %  tma_backend_bound
                                                  #      1,3 %  tma_bad_speculation
                                                  #     22,5 %  tma_frontend_bound
                                                  #     71,7 %  tma_retiring             ( +-  0,10% )

           0,57317 +- 0,00447 seconds time elapsed  ( +-  0,78% )

------------------------------------------------------------------------------------------------------------+
```


__Результаты для версии asm_inline_CRC32Hash без O3__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    34.33%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    22.66%  HashTable  HashTable             [.] HashTableFindElem(HashTable*, char*, HashTablePos*)
    16.45%  HashTable  libc.so.6             [.] __strcmp_evex
    10.96%  HashTable  HashTable             [.] HashTest
     7.16%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
     5.52%  HashTable  HashTable             [.] asm_inline_CRC32Hash(char*)

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          1 094,74 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,84% )
                 4      context-switches                 #    3,654 /sec                        ( +- 14,10% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    3,259 K/sec                       ( +-  0,00% )
     4 797 174 679      cycles                           #    4,382 GHz                         ( +-  0,10% )
    14 723 709 910      instructions                     #    3,07  insn per cycle              ( +-  0,00% )
     2 187 715 950      branches                         #    1,998 G/sec                       ( +-  0,00% )
            89 519      branch-misses                    #    0,00% of all branches             ( +-  0,50% )
                        TopdownL1                 #     29,2 %  tma_backend_bound
                                                  #      2,4 %  tma_bad_speculation
                                                  #      4,9 %  tma_frontend_bound
                                                  #     63,5 %  tma_retiring             ( +-  0,08% )

           1,09522 +- 0,00923 seconds time elapsed  ( +-  0,84% )

------------------------------------------------------------------------------------------------------------+
```

Как мы можем видеть, полученные результаты практически не отличаются от тех, что получены для полностью ассемблерной
версии хеш-функции.

Отличия в версиях можно описать тем, что в функции asm_CRC32Hash() присутствуют накладные расходы
на call и ret (__конвейер__ на них приостанавливается).

### Обсудим результаты

После победы над ассемблерными оптимизациями мы все-таки добились своего -
оптимизировали хэш-таблицу.

Все ранее полученные результаты можно поместить в таблицу:

| Версия                                                        | Время выполнения __без__ -O3, сек  |Время выполнения __с__ -O3, сек|
|:--------------------------------------------------------------|----------------|---------------|
|(0) Базовая версия                                             | 8,15 +- 0,01   | 2,25 +- 0,01  |
|(1) Базовая версия + asm_CRC32Hash()                           | 1,10 +- 0,01   | 0,55 +- 0,01  |
|(2) Базовая версия + asm_CRC32Hash() + SIMD поиск              |       -        | 0,40 +- 0,01  |
|(3) Базовая версия + asm_inline_CRC32Hash()                      | 1,10 +- 0,01   | 0,57 +- 0,01  |
|(4) Базовая версия + asm_inline_CRC32Hash() + SIMD поиск         |       -        | 0,39 +- 0,01  |

Самой быстрой версией по сравнению с базовой оказалась итерация №4 (__ускорение в 20,89 раз__), в которой использовались:
1) Возможности языка C/C++ вставлять куски ассемблерного кода в основной.

2) SIMD инструкции в совокупности с O3 (без O3, как говорилось ранее, в SIMD инструкциях не было бы смысла).

Судя по данным в таблице, можем видеть, что только asm_inline_CRC32Hash() ускоряет программу в 7,40 раз.
В то время как только -O3 ускоряет в 3,59 раза.

Можем сделать вывод о том, что ассемблерные оптимизации могут ускорить программу лучше, чем чистый -O3.

Но Ассемблером в коде раскидываться тоже не стоит, потому что после внедрения таких
низкоуровневых частей в код, его читаемость становится сильно хуже. А сама программа становится менее
переносимой на другие машины.

Например: в этой работе мне пришлось применить технологии AVX-512, доступные на новых поколениях процессоров.
Это значит, что на более старых процессорах моя программа банально не запустилась бы.

Поэтому, если нет особых требований в скорости программы,
лучше всего оптимизировать программу используя более общие методы по типу вынесения за цикл
независящих от него выражений, loop unrolling, избегать ненужных вызовов функций, избавляться от неэффективного кода и т.д..
А после воспользоваться каким-либо флагом оптимизации.

## Без этих людей, я бы не смог выполнить эту работу:
1) [Денис Дедков](https://github.com/d3phys)
2) [Илья Дединский](https://github.com/ded32)

## Источники
1) [картинка с хеш-таблицей](https://velog.io/@subeom7/HashMap%ED%95%B4%EC%8B%9C%EB%A7%B5-%EC%9D%B4%EB%9E%80)
2) [godbolt.org](godbolt.org)
