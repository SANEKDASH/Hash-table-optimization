# Hash-table-optimization
Эта __научно-популярная__ статья расскажет вам о том, как работает хеш-таблица и
как можно оптимизировать различные алгоритмы, используемые в ней, с  помощью Ассемблера.

## Что такое хеш-таблица?
<img src="./readme_src/hash_table.png" alt="hash_table.png" width="800"/>

Хеш-таблица - структура данных, которая базируется на соответствии ключа (какие-то данные) и его хеш-значения (какое-то число, зависящее от ключа).
Ключ с его хеш-значением обычно называют парой.

Хеш-таблица позволяет выполнять над собой три операции:
1) Поиск пары по ключу.
2) Добавление пары.
3) Удаление пары.


Большой __плюс__ хеш-таблицы - скорость по сравнению с другими.

>В лучшем случае, доступ к данным можно совершить за $O(1)$.
>В худшем (при возникновении коллизий) - за $O(n)$.

Большой __минус__ хеш-таблицы - использование большого кол-ва памяти по сравнению с другими структурами данных.
Но в наше время __дешевле__ повысить __объем__ оперативной памяти, чем повысить __производительность__ процессора.
Поэтому хеш-таблицы пользуются популярностью в определенных задачах.

### Коллизии
Ситуацию, при которой разным ключам соответствует одно и то же хеш-значение называется __коллизией__.

Существует несколько методов разрешения проблемы коллизий:
1) __Открытая адресация__:
        В массиве хранятся пары. А поиск идет
        в определенном порядке (обычно - в линейном или квадратичном).

2) __Списки__:
    Массив состоит из списков, содержащих пары с одинаковыми хеш-значениями.

3) __Двойное хеширование__:
    Грамотно подбираются две независимые хеш-функции: $h_1(x)$ и $h_2(x)$.
    Пусть $j$ - номер проверяемой ячейки, а $n$ - размер хеш-таблицы. Тогда поиск происходит следующим образом:

    $j_1 = (h_1(x))\ mod\ n$

    $j_2 = (h_1(x) + h_2(x))\ mod\ n$

    ...

    $j_i = (h_1(x) + (i - 1) * h_2(x))\ mod\ n$

4) __Переход к сбалансированному дереву__:
    Когда кол-во элементов в списке превышает определенное количество, можно заменить __односвязный список__ на __бинарное дерево поиска__. Этот метод может ускорить поиск от __$O(n)$__ до __O(log(n))__, но он подходит не ко всем типам данных.

В своей реализации я использовал метод списков.

### Load Factor

$Load\ factor$ - характеристика хеш-таблицы, описывающая среднее кол-во элементов в одном подмножестве.

Идеальным этот показатель считается когда $load\ factor \in (0;1 ]$.

В динамических хеш-таблицах (те, которые могут расширять кол-во списков) $load\ factor$ поддерживается около 1 с помощью добавления списков. Такие действия облегчают поиск и делают его алгоритмическую сложность O(1).

В этой работе мы пользуемся статической хеш-таблицей (т.е. без возможности добавлять списки), т.к в этой работе я хочу __ускорить__
алгоритмы хеш-таблицы, а при увеличении количества списков нужно проводить __рехеширование__ и __реаллокацию__, что замедляет их работу.

Размер хеш-таблицы подобрали так, чтобы получить $load\ factor$ равным примерно 7. Это позволит лучше увидеть узкие места в различных алгоритмах данной структуры данных.

Для тестирования в хеш-таблицу загружался текст произведения Шекспира "Гамлет" поделенный на слова.
Но мы заранее не знаем, сколько уникальных слов в тексте.

Поэтому алгоритм действий был следующим:
1)  Загрузить текст в хеш-таблицу.

>Функция добавления проверяет,
>существует ли добавляемый элемент таблице, если есть - не добавляет

2) Узнаем, сколько уникальных слов в тексте.

>Это число можно узнать по кол-ву элементов в хеш-таблице после загрузки
>Запоминаем это число.

3) Создаем новую хеш-таблицу, базируясь на известном кол-ве уникальных
элементов и load factor'е.

## Анализ хеш-функций
Для тестирования хеш-функций сначала в хеш-таблицу загружался текст произведения Шекспира "Гамлет" поделенный на слова.

__Количество списков__, полученное из алгоритма, указанного в предыдущем пункте, равно __797__


Идеальной хеш-функцией считается та, которая может обеспечить равномерное распределение элементов
хеш-таблицы по ее подмножествам/спискам при минимальном кол-ве __коллизий__.

Соответственно, мы можем определить насколько хорош алгоритм хеширования используя
такую вещь, как __дисперсия__.

__Дисперсия__ характеризует, насколько количество элементов в подможествах отличается от среднего кол-ва
элементов в подмножестве.

Считается дисперсия по следующей формуле:


$\sigma^{2} = \frac{\sum(x_i - <x>)^2}{n}$

Соответственно, __меньше__ дисперсия --> __равномернее__ распределение --> __лучше__ хеш-алгоритм.

Так же можно строить __гистограммы заселенности__ хеш-таблицы.
С помощью них наглядно увидеть, само распределение элементов по подножествам.

Далее будут приведены дисперсии и гистограммы заселенности для нескольких
реализованных мной хеш-алгоритмов.

1) хеш-функция, возвращающая ноль (далее ZeroHash):
```cpp
static uint64_t ZeroHash(char *data)
{
    return 0;
}

```

Гистограмма заселенности:
![alt text](./readme_src/zero_hash_diag.png)

Дисперсия: 40152.63

2) хеш-функция, возвращающая ASCII код первого символа в слове (далее StupidHash):
```cpp
static uint64_t StupidHash(char *data)
{
    return *data;
}

```


Гистограмма заселенности:
![alt text](./readme_src/stupid_hash_diag.png)

Дисперсия: 1741.259

3) хеш-функция, возвращающая длину слова (далее StrlenHash):
```cpp
static uint64_t StrlenHash(char *data)
{
    return strlen(data);
}

```


Гистограмма заселенности:
![alt text](./readme_src/strlen_hash_diag.png)

Дисперсия: 5558.15

4) хеш-функция, возвращающая сумму ASCII кодов всех символов в слове (далее SumHash):
```cpp
static uint64_t SumHash(char *data)
{
    uint64_t sum = 0;

    for (size_t i = 0; data[i] != '\0'; i++)
    {
        sum += data[i];
    }

    return sum;
}
```


Гистограмма заселенности:
![alt text](./readme_src/sum_hash_diag.png)

Дисперсия: 42.29

Может показаться, что эта хеш-функция весьма неплоха, но в действительности все иначе.
Давайте посмотрим на гистограмму заселенности хеш-таблицы, использующей эту функцию, с 4 тысячами списков:

![alt text](./readme_src/sum_hash_4k_diag.png)

Можем видеть, что распределение элементов здесь отнюдь не равномерное, и большая часть списков не задействуется.
Отсюда делаем вывод, что эту хеш-функцию лучше не использовать.

5) хеш-функция, возвращающая частное от суммы ASCII кодов всех символов в слове и его длинны (далее SumStrlenHash):
```cpp
static uint64_t SumStrlenHash(char *data)
{
    uint64_t sum = SumHash(data);

    uint64_t word_len = strlen(data);

    if (word_len == 0)
    {
        return 0;
    }

    return (uint64_t) (sum / word_len);
}
```


Гистограмма заселенности:
![alt text](./readme_src/sum_strlen_hash_diag.png)


Дисперсия: 2925.81

6) хеш-функция, использующая циклический сдвиг вправо (далее RorHash):
```cpp
static uint64_t RorHash(char *data)
{
    uint64_t hash_val = 0;

    for (size_t i = 0; data[i] != '\0'; i++)
    {
        hash_val = ((hash_val >> 1) | (hash_val << 63)) ^ data[i];
    }

    return hash_val;
}
```

Гистограмма заселенности:
![alt text](./readme_src/ror_hash_diag.png)


Дисперсия: 27.98

7) Хещ-функция использующая циклический сдвиг влево (Далле RolHash):
```cpp
static uint64_t RolHash(char *data)
{
    uint64_t hash_val = 0;

    for (size_t i = 0; data[i] != '\0'; i++)
    {

        hash_val = ((hash_val << 1) | (hash_val >> 63)) ^ data[i];

    }

    return hash_val;
}
```

Гистограмма заселенности:
![alt text](./readme_src/rol_hash_diag.png)

Дисперсия: 13.27

8) CRC32Hash:
```cpp
uint64_t CRC32Hash(char *data)
{
    uint32_t mask = 0;

    uint32_t hash_val = 0xFFFFFFFF;

    for (size_t i = 0; data[i] != 0; i++)
    {
        hash_val = hash_val ^ ((uint32_t) data[i]);

        for (size_t j = 0; j < 8; j++)
        {
            mask = -(hash_val & 1);

            hash_val = (hash_val >> 1) ^ (0xEDB88320 & mask);
        }
    }

    return (uint64_t) ~hash_val;
}
```

Гистограмма заселенности:
![alt text](./readme_src/crc32_hash_diag.png)

Дисперсия: 9.58

Можем видеть, что наиболее равномерное распределение элементов по спискам предоставляет хеш-функция CRC32Hash().
Поэтому в далее будем использовать ее.


### Странные дела с RorHash() и RolHash()
Почему-то случилось так, что в ассемблере существуют инструкции
ror и rol (циклический сдвиг вправо и влево соответственно), но в языках C/C++ они не реализованы.

Используя сайт [godbolt.org](https://godbolt.org/) я посмотрел, во что компилятор преобразует
код этих двух интересных функций.

Моему удивлению не было предела, когда я увидел заветные инструкции ror и rol:
![alt text](./readme_src/ror_rol.png)

Видимо компилятор g++ достаточно умен, чтобы найти в коде ror и rol.

Теперь давайте перейдём к оптимизации.

## Поиск узких мест
Чтобы что-то оптимизировать, сначала нужно узнать, что в программе требует оптимизации. То есть нужно найти так называемые __узкие места__.

Для поиска узких мест в алгоритмах хеш-таблицы я использовал утилиту __perf__.

Для тестов был взят текст произведения Шекспира "Король Лир", поделенный на слова.

Тест представляет из себя поиск всех слов из "Короля Лир" 2560 раз.

Для начала проведем __профилирование для базовой версии (без оптимизации)__.
Вот его результаты:

```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# ........  .........  ....................  ................................................................
#
    74.57%  HashTable  HashTable             [.] CRC32Hash(char*)
    10.93%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
     7.16%  HashTable  libc.so.6             [.] __strcmp_evex
     5.85%  HashTable  HashTable             [.] HashTableFindElem(HashTable*, char*, HashTablePos*)
     0.83%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          8 151,97 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,14% )
                31      context-switches                 #    3,803 /sec                        ( +- 12,12% )
                 1      cpu-migrations                   #    0,123 /sec                        ( +- 27,60% )
             3 569      page-faults                      #  437,808 /sec                        ( +-  0,00% )
    36 386 485 830      cycles                           #    4,464 GHz                         ( +-  0,07% )
    52 384 152 116      instructions                     #    1,44  insn per cycle              ( +-  0,00% )
     5 146 179 595      branches                         #  631,281 M/sec                       ( +-  0,00% )
           391 943      branch-misses                    #    0,01% of all branches             ( +- 24,15% )
                        TopdownL1                 #     65,6 %  tma_backend_bound
                                                  #      5,1 %  tma_bad_speculation
                                                  #      0,4 %  tma_frontend_bound
                                                  #     28,9 %  tma_retiring             ( +-  0,07% )

            8,1528 +- 0,0114 seconds time elapsed  ( +-  0,14% )

------------------------------------------------------------------------------------------------------------+
```

__Результаты профилирования для базовой версии + O3__:

```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    51.85%  HashTable  HashTable         [.] CRC32Hash(char*)
    18.45%  HashTable  libc.so.6         [.] __strcmp_evex
    16.21%  HashTable  HashTable         [.] ListFind(List*, char*, unsigned long*)
    10.97%  HashTable  HashTable         [.] TestHashTable(HashTable*, WordSet*)
     1.96%  HashTable  HashTable         [.] strcmp@plt

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          2 253,32 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,08% )
                 8      context-switches                 #    3,550 /sec                        ( +- 14,95% )
                 0      cpu-migrations                   #    0,000 /sec
             3 569      page-faults                      #    1,584 K/sec                       ( +-  0,01% )
    10 062 631 047      cycles                           #    4,466 GHz                         ( +-  0,05% )
    22 938 934 302      instructions                     #    2,28  insn per cycle              ( +-  0,00% )
     1 594 637 228      branches                         #  707,685 M/sec                       ( +-  0,00% )
           117 260      branch-misses                    #    0,01% of all branches             ( +- 14,22% )
                        TopdownL1                 #     51,8 %  tma_backend_bound
                                                  #      2,1 %  tma_bad_speculation
                                                  #      1,2 %  tma_frontend_bound
                                                  #     44,9 %  tma_retiring             ( +-  0,08% )

           2,25392 +- 0,00170 seconds time elapsed  ( +-  0,08% )

------------------------------------------------------------------------------------------------------------+
```


Как можем заметить, узкими местами в алгоритмах хеш-таблицы являются следующие функции:
1) CRC32Hash()
2) ListFind() (вызывается следующей функцией)
3) HashTableFindElem()

>__strcmp_evex() я здесь не учел, так как эту функцию писали мужики, знающие свое дело.
>Вряд ли я смогу его ускорить, но есть одна хитрость, которая мне в этом поможет.
>Позже я вам о ней поведаю.

__Что ж, давайте оптимизировать!__

## Оптимизация

Перед тем, как приступить к оптимизации, хотелось бы подчеркнуть тот факт, что ускорение, полученное мной, может розниться
от системы к системе. Ускорение может зависеть от различного множества всяческих факторов: от версии компилятора до
комплектующих вашего ПК.
Ниже приведены параметры моей системы:

|                               |                        |
|:-----------------------------:|:----------------------:|
|Процессор                      | Intel core i5 11400H.  |
|Кол-во оперативной памяти      | 16гб.                  |
|ОС                             | Ubuntu Linux 22.04.4.  |
|Версия ядра Ubuntu             | 6.5.0-26-generic.      |
|Используемый компилятор        | g++                    |
|Версия компилятора             | 11.4.0                 |


Давайте сперва попытаемся оптимизировать самую тяжелую функцию - __функцию хеширования__.

### Оптимизация №1: хеш-функция

Так совпало (зуб даю, реально совпало), что существует:
1) инструкция процессора __crc32__
2) intrinsic функция ___mm_crc32_u8()__

 А методов реализовывать оптимизацию существует аж целых 3:
1) функция языка Си под названием asm()
2) функция написанная на языке Ассемблер, вызываемая в Си
3) intrinsic функции

Для примера я написал функцию на Ассемблере, которая считает хеш CRC32:
```nasm
asm_CRC32Hash:
; Entering function
    push rbp
    mov rbp, rsp

    xor rax, rax
; Hash start value
    mov eax, 0xffffffff

    jmp .HashTest
.HashCycle:
    crc32 eax, byte [rdi]

    inc rdi
.HashTest:
    cmp byte [rdi], 0
    ja .HashCycle

; Leaving function
    mov rsp, rbp
    pop rbp

    ret
```

__Результаты профилирования для версии с asm_CRC32Hash()__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object         Symbol
# ........  .........  ....................  ................................................................
#
    43.91%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    25.63%  HashTable  libc.so.6             [.] __strcmp_evex
    13.99%  HashTable  HashTable             [.] HashTableFindElem(HashTable*, char*, HashTablePos*)
     5.87%  HashTable  HashTable             [.] asm_CRC32Hash.HashTest
     4.67%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
     3.35%  HashTable  HashTable             [.] strcmp@plt
     1.86%  HashTable  HashTable             [.] asm_CRC32Hash

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          1 090,99 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,83% )
                 4      context-switches                 #    3,666 /sec                        ( +- 15,31% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    3,270 K/sec                       ( +-  0,01% )
     4 726 720 243      cycles                           #    4,332 GHz                         ( +-  0,21% )
    13 781 524 236      instructions                     #    2,92  insn per cycle              ( +-  0,00% )
     2 115 240 637      branches                         #    1,939 G/sec                       ( +-  0,00% )
           313 011      branch-misses                    #    0,01% of all branches             ( +- 71,07% )
                        TopdownL1                 #     31,0 %  tma_backend_bound
                                                  #      2,5 %  tma_bad_speculation
                                                  #      6,5 %  tma_frontend_bound
                                                  #     60,0 %  tma_retiring             ( +-  0,18% )

           1,09149 +- 0,00901 seconds time elapsed  ( +-  0,83% )

------------------------------------------------------------------------------------------------------------+
```

Как можем видеть, функция хеширования сдвинулась с первого на последнее место в чарте вызовов.
Это не может не радовать.
Но у нас все еще осталась работа в виде оптимизации функции поиска.

### Оптимизация №2: поиск

Как можем видеть из call graph, в функции HashTableFindElem() расходуется на ListFInd() и __strcmp_evex(), который вызывается с-под ListFind().

Оптимизация __strcmp_evex() является довольно сложной ~~быть может невозможной~~ задачей, так как он уже оптимизирован.
Хитрость в этом случае заключается в том, что в данной задаче (поиск заранее известных слов) мы можем переити от общего к частному.

> Длины слов в обоих текстах не превышают 37 --> не превышают 64 символов.

С помощью технологии AVX-512, поддерживаемой на моем процессоре, я попытался ускорить алгоритм поиска, используя intrinsic функции.

Список используемых intrinsic функций:
1) _mm512_load_epi64() - загружает в регистр 64 байт памяти, расположенной по адресу, выравненному по 64.

2) _mm512_cmp_epi16_mask() - сравнивает две пачки памяти по 64 байт каждая.

__Результаты профилирования для версии asm_CRC32Hash() + O3 (до оптимизации поиска)__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object         Symbol
# ........  .........  ....................  ................................................................
#
    33.79%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    31.93%  HashTable  libc.so.6             [.] __strcmp_evex
    13.90%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
    10.18%  HashTable  HashTable             [.] asm_CRC32Hash.HashTest
     5.76%  HashTable  HashTable             [.] strcmp@plt
     3.26%  HashTable  HashTable             [.] asm_CRC32Hash
------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            544,64 msec task-clock                       #    0,999 CPUs utilized               ( +-  1,13% )
                 2      context-switches                 #    3,672 /sec                        ( +- 22,15% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    6,551 K/sec                       ( +-  0,01% )
     2 314 039 065      cycles                           #    4,249 GHz                         ( +-  0,19% )
     8 149 612 314      instructions                     #    3,52  insn per cycle              ( +-  0,00% )
     1 680 214 206      branches                         #    3,085 G/sec                       ( +-  0,00% )
            93 117      branch-misses                    #    0,01% of all branches             ( +-  4,70% )
                        TopdownL1                 #      8,1 %  tma_backend_bound
                                                  #      1,4 %  tma_bad_speculation
                                                  #     17,1 %  tma_frontend_bound
                                                  #     73,4 %  tma_retiring             ( +-  0,08% )

           0,54514 +- 0,00615 seconds time elapsed  ( +-  1,13% )

------------------------------------------------------------------------------------------------------------+
```

__Результаты профилирования для версии asm_CRC32Hash() + SIMD + O3 (после оптимизации поиска)__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object         Symbol
# ........  .........  ....................  ................................................................
#
    53.48%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    23.14%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
    16.76%  HashTable  HashTable             [.] asm_CRC32Hash.HashTest
     4.66%  HashTable  HashTable             [.] asm_CRC32Hash
------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            402,40 msec task-clock                       #    0,999 CPUs utilized               ( +-  1,07% )
                 2      context-switches                 #    4,970 /sec                        ( +- 28,54% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    8,867 K/sec                       ( +-  0,00% )
     1 696 988 095      cycles                           #    4,217 GHz                         ( +-  0,32% )
     5 295 247 151      instructions                     #    3,12  insn per cycle              ( +-  0,00% )
     1 239 582 166      branches                         #    3,081 G/sec                       ( +-  0,00% )
            79 113      branch-misses                    #    0,01% of all branches             ( +-  0,35% )
                        TopdownL1                 #      6,2 %  tma_backend_bound
                                                  #      1,3 %  tma_bad_speculation
                                                  #     23,5 %  tma_frontend_bound
                                                  #     69,1 %  tma_retiring             ( +-  0,28% )

           0,40287 +- 0,00428 seconds time elapsed  ( +-  1,06% )

------------------------------------------------------------------------------------------------------------+
```
Как видим, с помощью intrinsic функций получилось еще больше ускорить программу.

А strcmp() и вовсе пропал из чарта вызовов (неудивительно, т.к. он перестал использоваться).

Так же стоит отметить, что флаг __-O3__ (или -O1, -O2) здесь __существенен__, т.к. без этого флага эффективность intrinsic ф-ций заметно падает.

### Оптимизация №3: вернемся к хешу

Давайте посмотрим на еще один вариант оптимизации хеш-алгоритма - inline Ассемблер.

Язык C/C++ позволяет делать ассемблерные вставки прямо посреди основного кода программы.

Как мне кажется, к этому методу стоит только при каком-то определенном требовании свыше,
или настоять на другом методе, т.к. он достаточно сильно ухудшает читаемость кода,
особенно если используется больше одного раза.

Новая функция хеширования выглядит так:
```cpp

static inline uint64_t asm_inline_CRC32Hash(char *data)
{
    uint64_t hash_val = 0;

        asm(
            "    xor rax, rax                       \n"
            "    mov eax, 0xffffffff                \n"
            "    jmp HashTest                       \n"
            "HashCycle:                             \n"
            "    crc32 eax, byte ptr [%[str]]       \n"
            "    inc %[str]                         \n"
            "HashTest:                              \n"
            "    cmp byte ptr [%[str]], 0           \n"
            "    ja HashCycle                       \n"
            "    mov %[hash], rax                   \n"
                : [hash] "=m" (hash_val)
                : [str]   "d" (data)
           :);

    return hash_val;
}

```

__Результаты профилирования для версии asm_inline_CRC32Hash + SIMD ListFind + O3__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    49.18%  HashTable  HashTable         [.] ListFind(List*, char*, unsigned long*)
    21.11%  HashTable  HashTable         [.] TestHashTable(HashTable*, WordSet*)
    19.77%  HashTable  HashTable         [.] HashTest
     8.04%  HashTable  HashTable         [.] asm_inline_CRC32Hash(char*)
     0.38%  HashTable  libc.so.6         [.] _int_malloc

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            392,14 msec task-clock                       #    0,999 CPUs utilized               ( +-  0,97% )
                 2      context-switches                 #    5,100 /sec                        ( +- 39,32% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    9,099 K/sec                       ( +-  0,00% )
     1 682 623 969      cycles                           #    4,291 GHz                         ( +-  0,65% )
     5 874 968 451      instructions                     #    3,49  insn per cycle              ( +-  0,00% )
     1 312 043 248      branches                         #    3,346 G/sec                       ( +-  0,00% )
            78 707      branch-misses                    #    0,01% of all branches             ( +-  0,42% )
                        TopdownL1                 #     12,5 %  tma_backend_bound
                                                  #      1,6 %  tma_bad_speculation
                                                  #     10,1 %  tma_frontend_bound
                                                  #     75,8 %  tma_retiring             ( +-  0,31% )

           0,39257 +- 0,00380 seconds time elapsed  ( +-  0,97% )

------------------------------------------------------------------------------------------------------------+
```

__Результаты для версии asm_inline_CRC32Hash + O3__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    32.02%  HashTable  HashTable         [.] ListFind(List*, char*, unsigned long*)
    31.55%  HashTable  libc.so.6         [.] __strcmp_evex
    12.99%  HashTable  HashTable         [.] TestHashTable(HashTable*, WordSet*)
    12.11%  HashTable  HashTable         [.] HashTest
     5.24%  HashTable  HashTable         [.] strcmp@plt
     4.81%  HashTable  HashTable         [.] asm_inline_CRC32Hash(char*)
     0.27%  HashTable  libc.so.6         [.] _int_malloc

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

            572,70 msec task-clock                       #    0,999 CPUs utilized               ( +-  0,78% )
                 2      context-switches                 #    3,492 /sec                        ( +- 19,83% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    6,230 K/sec                       ( +-  0,01% )
     2 513 501 962      cycles                           #    4,389 GHz                         ( +-  0,22% )
     8 729 463 053      instructions                     #    3,47  insn per cycle              ( +-  0,00% )
     1 752 697 415      branches                         #    3,060 G/sec                       ( +-  0,00% )
           115 376      branch-misses                    #    0,01% of all branches             ( +-  7,66% )
                        TopdownL1                 #      4,6 %  tma_backend_bound
                                                  #      1,3 %  tma_bad_speculation
                                                  #     22,5 %  tma_frontend_bound
                                                  #     71,7 %  tma_retiring             ( +-  0,10% )

           0,57317 +- 0,00447 seconds time elapsed  ( +-  0,78% )

------------------------------------------------------------------------------------------------------------+
```


__Результаты для версии asm_inline_CRC32Hash без O3__:
```
------------------------------------------------------------------------------------------------------------+
Call persantage:                                                                                            |
------------------------------------------------------------------------------------------------------------+

# Overhead  Command    Shared Object     Symbol
# ........  .........  ................  ....................................................................
#
    34.33%  HashTable  HashTable             [.] ListFind(List*, char*, unsigned long*)
    22.66%  HashTable  HashTable             [.] HashTableFindElem(HashTable*, char*, HashTablePos*)
    16.45%  HashTable  libc.so.6             [.] __strcmp_evex
    10.96%  HashTable  HashTable             [.] HashTest
     7.16%  HashTable  HashTable             [.] TestHashTable(HashTable*, WordSet*)
     5.52%  HashTable  HashTable             [.] asm_inline_CRC32Hash(char*)

------------------------------------------------------------------------------------------------------------+
Stat:                                                                                                       |
------------------------------------------------------------------------------------------------------------+

          1 094,74 msec task-clock                       #    1,000 CPUs utilized               ( +-  0,84% )
                 4      context-switches                 #    3,654 /sec                        ( +- 14,10% )
                 0      cpu-migrations                   #    0,000 /sec
             3 568      page-faults                      #    3,259 K/sec                       ( +-  0,00% )
     4 797 174 679      cycles                           #    4,382 GHz                         ( +-  0,10% )
    14 723 709 910      instructions                     #    3,07  insn per cycle              ( +-  0,00% )
     2 187 715 950      branches                         #    1,998 G/sec                       ( +-  0,00% )
            89 519      branch-misses                    #    0,00% of all branches             ( +-  0,50% )
                        TopdownL1                 #     29,2 %  tma_backend_bound
                                                  #      2,4 %  tma_bad_speculation
                                                  #      4,9 %  tma_frontend_bound
                                                  #     63,5 %  tma_retiring             ( +-  0,08% )

           1,09522 +- 0,00923 seconds time elapsed  ( +-  0,84% )

------------------------------------------------------------------------------------------------------------+
```


Как мы можем видеть, полученные результаты практически не отличаются от тех, что получены для полностью ассемблерной
версии хеш-функции.

Отличия в O3 версиях можно описать тем, что в функции asm_CRC32Hash() присутствуют накладные расходы
на call и ret (__конвейер__ на них приостанавливается).

### Обсудим результаты

После неравного боя с ассемблерными оптимизациями мы все-таки добились своего -
оптимизировали хэш-таблицу.

Все ранее полученные результаты можно поместить в таблицу:

| Версия                                                        |Среднее время выполнения, сек  ||
|:--------------------------------------------------------------|----------------|---------------|
|                                                               | __без__ -O3    | __с__ -O3     |
|(0) Базовая версия                                             | 8,15 +- 0,01   | 2,25 +- 0,01  |
|(2) Базовая версия + asm_CRC32Hash()                           | 1,10 +- 0,01   | 0,55 +- 0,01  |
|(4) Базовая версия + asm_CRC32Hash() + SIMD поиск              |       -        | 0,40 +- 0,01  |
|(6) Базовая версия + asm_inline_CRC32Hash                      | 1,10 +- 0,01   | 0,57 +- 0,01  |
|(5) Базовая версия + asm_inline_CRC32Hash + SIMD поиск         |       -        | 0,39 +- 0,01  |

Самой быстрой версией по сравнению с базовой оказалась итерация №5 (ускорение в 17.1 раз), в которой использовались:
1) Возможности языка C/C++ вставлять куски ассемблерного кода в основной.

2) SIMD инструкции в совокупности с O3 (без O3, как говорилось ранее, в SIMD инструкциях не было бы смысла).

В заключение хочется сказать, что к ассемблерным оптимизациям стоит прибегать в случае, когда
требуется выжать максимум из аппаратных возможностей конкретной машины, т.к.
после внедрения внедрения таких оптимизаций код программы становится менее читаемым, а
сама программа менее переносимой на другие машины.

Например: в этой работе мне пришлось применить технологии AVX-512, доступные на новых поколениях процессоров.
Это значит, что на более старых процессорах моя программа банально не запустилась бы.

### Без этих людей, я бы не смог выполнить эту работу:
1) [Денис Дедков](https://github.com/d3phys)
2) [Илья Дединский](https://github.com/ded32)
